from bs4 import BeautifulSoup, Tag, NavigableString
import sys
import ExprParser, ExprSemantics
from collections import defaultdict as _defdict, namedtuple

INDENT = '  '
def run_file(f):
    return run_string(open(f).read())

def compile(s, source):
    """Return Python that implements the template"""
    dom = BeautifulSoup(s)
    c = Compiler(source)
    root = dom.contents[0]
    root.attrs.setdefault('def', "html(*)")
    for attr in 'if', 'for':
        if attr in root.attrs:
            warn("Attr not allowed on root tag: "+attr)
            del root.attrs[attr]
    c.tag(root)
    return c.module.join()

MODULE_PREAMBLE = '# Generated by t_compile from %s'
MODULE_IMPORTS = ['t_tmpl']
FN_PREAMBLE = '_, _q, _emit = t_tmpl._ctx("attr")'
BUILTINS = set([
# Python builtins
'abs', 'all', 'any', 'float', 'int', 'len', 'max', 'min', 'next', 'range', 'round',
])


from t_ir import IR

class PyIR(IR):
    star = False
    starix = None
    name = None
    args = None
    def DS(self, (name, args)):
        # ...don't add to su
        self.name = name
        self.args = args[:]
        if '*' in args:
            self.star = True
            self.starix = args.index('*')
            del args[self.starix]

    def LP(self, name):
        if self.star:
            self.args.insert(name, self.starix)
            self.starix += 1
        else:
            warn("Param used without * in args, treating as regular local")
        self.LV(name)

    

class Out:
    "Gathers the python code that forms the results"
    def __init__(self):
        self.lines = []
        self.emits = []
        self.indent = 0

    def add(self, code, indent=0):
        self.flush()
        spaces = self.indent * INDENT
        self.indent += indent
        self.lines.append(spaces + code.replace('\n', '\n'+spaces))

    def flush(self):
        if self.emits:
            x = repr(''.join(self.emits))
            self.emits = []
            self.emit(x)
    
    def dedent(self, dedent=1):
        if dedent: 
            self.flush()
            self.indent -= dedent

    def emit(self, expr):
        self.add("_emit(%s)" % expr)

    def emit_s(self, text):
        self.emits.append(text)

    def join(self):
        self.flush()
        return '\n'.join(self.lines)

class Module:
    def __init__(self, source):
        self.source = source
        self.defs = []
        self.ir = []
        self.modules = set(MODULE_IMPORTS)
        self.funcnames = set()
        
    def add_import(self, module):
        self.modules.add(module)
        
    def startdef(self, name, args, filters):
        argl = args.split(', ')
        if argl and argl[-1][:2] == '**':
            argl.pop()
                
        ir = PyIR()
        self.ir.append(ir)
        map(ir.FILT, filters)
        ir.DEF(name, argl)
        ir.SETUP('attr')

        f = Function(self, name, args, filters)
        self.defs.append(f)

        if name in self.funcnames:
            warn("Macro %s already" % name)
        else:
            self.funcnames.add(name)
        return f, ir
        
    def global_name(self, name):
        return name in self.funcnames or name in self.modules or name in BUILTINS
        
    def join(self):
        l = []
        add = l.append
        add(MODULE_PREAMBLE % self.source)
        for m in self.modules:
            add('import '+m)
        add('')
        for f in self.ir:
            add(f.join())
            add('')
        return '\n'.join(l)
        
class Function(Out):
    def __init__(self, module, name, args, filters):
        Out.__init__(self)
        self.module = module
        
        # old way
        self.lines = ['@'+filt for filt in filters]
        self.defix = len(self.lines)
        self.add('def <reserved>', 1)
        self.add(FN_PREAMBLE)
        self.name = name
        self.args = args.split(', ')
        self.locals = []
        self.lvars = set()
        if '*' in self.args:
            self.starix = self.args.index('*')
            del self.args[self.starix]
        else:
            self.starix = -1
        
    def join(self):
        self.lines[self.defix] = 'def %s(%s):' % (self.name, ', '.join(self.args))
        if self.locals:
            ix = self.defix + 1
            stmts = []
            tmpl = INDENT + '%s = _kw.get(%r)'
            #TODO
            for var in self.locals:
                if not self.module.global_name(var):
                    warn("In %s: variable %s not defined as a paramter" % (self.name, var))
                    stmts.append(tmpl % (var, var))
            self.lines[ix:ix] = stmts
        return Out.join(self)

    def add_local(self, var):
        if var in self.args: return
        if var in self.locals: return
        if var in self.lvars: return
        self.locals.append(var)

    def add_lvar(self, lvar):
        self.lvars.add(lvar)
        return lvar

    def add_param(self, p):
        if p in self.args:
            warn("Parameter already exists")
        if self.starix > -1:
            self.args.insert(self.starix, p)
            self.starix += 1
        else:
            warn("Paramter can't be added (use * in args list to allow dynamically added params)")
                
class Compiler:
    def __init__(self, source):
        self.out = self.module = Module(source)
        self.parser = ExprParser.ExprParser(
            parseinfo=True, 
            semantics=ExprSemantics.ExprSemantics(PyCoder(self.add_var, self.add_module, self.add_lvar))
        )
        self.tags = []
        self.outs = []
        
    def add_var(self, var):
        assert var != 'itervalues'
        self.out.add_local(var)
        self.ir.LV(var)

    def add_lvar(self, var):
        return self.out.add_lvar(var)

    def add_module(self, module):
        self.module.add_import(module)
        
    def startdef(self, name, args, filters):
        self.outs.append(self.out)
        self.out, self.ir = self.module.startdef(name, args, filters)
        
    def enddef(self):
        self.out = self.outs.pop()
        self.ir.finish()
        
    def tag(self, tag):
        if tag.name == 'else':
            return self._else(tag)
        ts = self._Tagstate(tag.name, tag.get('id'))
        self.tags.append(ts)
        self._process_attrs(tag.attrs, ts)
        self._children(tag)
        self._finalize(ts)
        self.tags.pop()

    def _default(self, attr, ts, v):
        if v: return v
        method = getattr(self, '_default_'+attr, lambda ts: v)
        return method(ts)

    def _default_for(self, ts):
        return '.'
        
    def _default_def(self, ts):
        return self._name_default(ts)+'(*)'
        
    def _default_param(self, ts):
        return self._name_default(ts)
        
    def _default_set(self, ts):
        return self._name_default(ts) + ' |contents'

    def _name_default(self, ts):
        if ts.id and ts.name not in ['head', 'body']:
            return ts.id
        # check that id is a valid name
        # check that name != 'do'
        return ts.name
    
    _attrs = 'param', 'def', 'set', 'use', 'for', 'if', 'elide'
    def _process_attrs(self, attrs, ts):
        attrs = attrs.copy()
        if attrs.get('if') == '':
            # blank 'if' is alias for elide
            attrs['elide'] = attrs.pop('if')
        for attr in self._attrs:
            if attr not in attrs: continue
            try:
                v = self._default(attr, ts, attrs.pop(attr))
                result = self.parser.parse(v, rule_name=attr+'Expr')
                getattr(self, '_process_'+attr)(ts, result)
            except AssertionError:
                import traceback
                traceback.print_exc()
            except Exception, e:
                print 'error:', attr, v, e
                #import traceback
                #traceback.print_exc()
                raise
                
        if ts.emit_tag:
            self.out.emit_s('<'+ts.name)
            self.ir.C('<'+ts.name)
            for attr, val in attrs.items():
                self.out.emit_s(' '+attr+'="')
                self.ir.C(' '+attr+'="')
                if isinstance(val, list):
                    #multi-value attribute
                    val = ' '.join(val)
                self.parse_text(val)
                self.ir.C('"')
            self.out.emit_s('>')
            self.ir.C('>')
        else:
            if attrs:
                warn("Leftover attrs on <do>")

    class _Tagstate:
        ret = None
        dedent = 0
        if_pending = 0
        elide_pending = 0
        def __init__(self, name, id): 
            self.adds = []
            self.emit_tag = name != 'do'
            self.name = name
            self.id = id
            self.ir = IR()

        def add(self, o):
            self.adds.append(o)

    def _finalize(self, ts):
        if ts.emit_tag:
            self.out.emit_s('</%s>' % ts.name)
            self.ir.C('</%s>' % ts.name)
        self._finish_elide(ts)
        self.out.dedent(ts.dedent)
        map(self.out.add, ts.adds)
        #print ts.ir.lists
        self.ir.add(ts.ir)
        if ts.ret:
            self.out.add(ts.ret) # handled in map above
            self.enddef()

    def _finish_elide(self, ts):
        if ts.elide_pending:
            self.out.add('_noelide, _content, _emit = _.elidecheck()')
            self.out.add('if _noelide:', 1)
            self.out.emit('_content')
            self.ir.SE()
            self.ir.IFSTART('_noelide')
            self.ir.UV('_content')
            ts.ir.IFEND()
            ts.dedent += 1
            ts.elide_pending = False

    def _process_elide(self, ts, result):
        self.out.add('_emit = _.elidestart()')
        self.ir.SS()
        ts.elide_pending = True
        
    def _process_def(self, ts, result):
        self.startdef(*result)
        ts.ret = 'return _.result()'
        ts.ir.DD()

    def _process_set(self, ts, result):
        name, filters, contents = result
        if contents: ts.emit_tag = False

        self.out.add('_emit = _.push()')
        self.ir.SETSTART()

        ts.ir.SETEND(name, filters)
        
        if filters:
            expr = '_content'
            for filt in filters:
                expr = '%s( %s )' % (filt, expr)
            ts.add('_content, _emit = _.pop()')
            ts.add(name + ' = ' + expr)
        else:
            ts.add(name + ', _emit = _.pop()')

    def _process_if(self, ts, test):
        self.ir.IFSTART(test)
        ts.if_pending = 1
        ts.ir.IFEND()

        self.out.add('if %s:' % test, 1)
        ts.dedent +=1 #old
        
    def _process_param(self, ts, v):
        map(self.out.add_param, v)
        map(self.ir.SP, v)
        if len(v) == 1:
            self.add_lvar('dot')
            self.out.add('dot = ' + v[0])
            self.ir.LE('dot', v[0])

    def _process_for(self, ts, obj):
        tup, old = obj
        
        if len(tup) == 2:
            n1, expr = tup
            self.ir.FOR1(n1, expr)
        else:
            n1, n2, expr = tup
            self.ir.FOR2(n1, n2, expr)
        ts.ir.ENDFOR()
        
        self.out.add(old, 1)
        ts.dedent += 1
        
    def _process_use(self, ts, ast):
        self.out.add('_emit = _.push()')
        ts.ir.CS()
        
        ts.add('dot, _emit = _.pop()')
        ts.add('_emit(_.apply(%s, locals()))' % ast)
        ts.ir.CD1()
        ts.ir.CD2(ast)

    def _children(self, tag):
        for c in tag.children:
            if isinstance(c, NavigableString):
                self.parse_text(c)
            else:
                self.tag(c)
    
    def _else(self, tag):
        tags = []
        for ts in self.tags[::-1]:
            if ts.emit_tag:
                tags.append(ts.name)
            if ts.if_pending or ts.elide_pending:
                break
        else:
            warn("No if found for <else>")
            return self._children(tag)
             
        if tags:
            warn("<else> synthesized tags: "+str(tags))
        
        endtags = ''.join(['</%s>' % t for t in tags])
        starttags = ''.join(['<%s>' % t for t in tags])

        self.out.emit_s(endtags)
        self.ir.C(endtags)
        self._finish_elide(ts)
                     
        attrs = tag.attrs
        if 'if' in attrs:
            test = self.parser.parse(attrs.pop('if'), rule_name='test')
            stmt = 'elif %s:' % test
            self.out.dedent()
            self.out.add(stmt, 1)
            self.ir.ELIF(test)
        else:
            self.out.dedent()
            self.out.add('else:', 1)
            self.ir.ELSE()

        if attrs:
            warn("Extraneous attributes on <else/>")

        self.out.emit_s(starttags)
        self.ir.C(starttags)

        self._children(tag)
    
    def parse_text(self, text):
        result = []
        ix = text.find('{')
        while ix > -1:
            if text[ix:ix+2] == '{{':
                ix = text.find('{', ix+2)
                if ix == -1: break
                continue
            if ix > 0:
                self.out.emit_s(text[:ix])
                self.ir.C(text[:ix])
                text = text[ix:]
            (asgn, exprs, emit, star), text = self.parser.parse(text, rule_name='top')
            
            for lvar, expr in asgn:
                self.add_lvar(lvar)
                self.out.add('%s = %s' % (lvar, expr))
                self.ir.LE(lvar, expr)
            map(self.out.add, exprs)
            map(self.ir.PY, exprs)
            if star:
                type, name = star
                method = {'*': 'star', '++': 'plusplus'}[type]
                self.add_lvar(name)
                self.out.add('%s = _.%s()' % (name, method))
                self.ir.LVARE(name, method)
            if emit:
                self.out.emit(emit)
                self.ir.QV(emit)
            
            ix = text.find('{')
        self.out.emit_s(text)
        self.ir.C(text)
        
def warn(s):
    print "Warning:", s


class PyCoder(ExprSemantics.Coder):
    def __init__(self, varref=lambda v:None, modref=lambda m:None, lvarref=lambda: None):
        self.varref = varref
        self.modref = modref
        self.lvarref = lvarref

    def assign(self, lvar, expr):
        self.lvarref(lvar)
        return (lvar, expr)
        
    def dotpath(self, args):
        args[0] = 'dot'
        return self.path(args)

    def regex(self, regex, expr):
        self.modref('re')
        return 'bool(re.search(%r, %s))' % (regex, expr)

    def path(self, args):
        n = args.pop(0)
        self.varref(n)
        if len(args) == 1:
            n = '_.get1(%s, %r)' % (n, args[0])
        elif args:
            n = '_.get(%s, %s)' % (n, args)
        return n
        
    def lookup(self, path, key):
        return '_.get1(%s, %s)' % (path, key)

    def extpath(self, module, path):
        return '_.load(%r, %s)' % (module, path)

    def arglist(self, args):
        args.append('**_kw')
        return ', '.join(args)

    def top(self, asgn, exprs, emit, star):
        return asgn, exprs, emit, star
         
    def set(self, name, filter, contents):
        return name, filter or [], contents

    def funcdef(self, name, args, filters):
        return name, args, filters
        
    def for2(self, n1, n2, rvar):
        old = 'for %s, %s in _.items(%s):' % (self.lvarref(n1), self.lvarref(n2), rvar)
        return (n1, n2, rvar), old
        
    def for1(self, n1, rvar):
        old = 'for %s in _.iter(%s):' % (self.lvarref(n1), rvar)
        return (n1, rvar), old

    def for0(self, rvar):
        return self.for1('dot', rvar)

    def if_stmt(self, test):
        return test
        
TESTS = '''
<html>
</html>
----
<html>
  {1}
</html>
----
<html>
  {a}
</html>
----
<html>
  <p if="a">a!</p>
  <p if="a">a!<else>no</p>
  <p if="a">a!<else if="0">no</p>
</html>
----
<html>
  {"hi"}/{0}/{['hi']}/{a={{a:1,b:2}};a}
</html>
----
<html>
    {1..10}
    {1...10}
    {10...1}
    {10..1}

    <p for="i in 1...5">{i}</p>
    <p for="1...5">{.}</p>
    <p for="i, j in ['a', 'b', 'c']">{i}/{j}</p>

    <p for="i, j in ['a', 'b', 'c']" if="i > 1">
        {i}/{j}
    </p>
</html>
----

'''

CRASH = '''
<p if="a">a!<else><else if="0">no</p>
'''

MORETESTS = '''
<html>
  <h1 id="foo" style="{sty}">Hello world!</h1>
  <div def="a()" if="1">
      Hello world!
  </div>
  <div def="b(c)">
      <do if="c > 1">
          c={c}
      </do>
  </div>
  <do for="0..7">{b(.)}</do>
  <ol>
      <li for="sys::path">{.}</li>
  </ol>
</html>
----
<html>
    <ul>
    <li for="sys::path">{.}</li>
</html>
----
<html>
  <h1 def="b(a)" if="a">
      {a}
      <else>
      Nope
  </h1>
</html>
----
<html def="html(a)">
  <do def="b(a)" if="a">
      <h1>{a}</h1>
  <else>
      Nope
  </do>
  <do def="b(a)" if="a==1">
      <h1>{a}</h1>
  <else if="a==2">
      <h2>{a}</h2>
  </do>
  <h1 if>{""}</h1>
  <h2 if>{""}<else>no a!</h1>
</html>
----
<html>
  <foo param>{.}</foo>
  <h1 def="b(a)" if="a">
      {a}
      <else>
      Nope
  </h1>
</html>
----
<html use="base::html">
    <title set>Foo</title>
    <article set>
        Foo bar
    </article>
</html>
----
<html>
    {a}
</html>
----
<html>
    {a ~ /[0-9]/ ? 'number' : 'other'}
    {b = {['one', 'two', 'three']}; c = {{one: 'uno', two: 'dos', three: 'tres'}}}
    {d = {b[len(a)]}; c[d]}
    :{c.what}:{c[a]}:
</html>
----
<table def="table(t)">
    <tr for="r in t">
        <td for="c in r.itervalues()">{c}</td>
    </tr>
</table>
----
<table def>
    <tr param for>
        <td for=".itervalues()">{.}</td>
    </tr>
</table>
----
<table def>
    <tr param for>
        <td for="k, v in .">{v}</td>
    </tr>
</table>
----
Foo
<div class="{*:cls}">
  Errors: {++:errcount} Warnings: {++:warncount}
  {*:toomanyissuetext}
  <div for="[{type: 'error', title:'Hello'}, {type:'info', title:'Info'}, {type: 'error', title:'Hello'}, {type: 'error', title:'Hello'}, {type: 'error', title:'Hello'}]">
    {errcount(.type == 'error' ? 1 : 0); warncount(.type == 'error' ? 1 : 0); cls(.type); ""}
    <h2>{.title}</h2>
    Foo
  </div>
  <p use="toomanyissuetext" if="4 >= errcount > 1">There were some errors</p>
  <p use="toomanyissuetext" if="errcount > 3">FIX YOUR STUFF</p>
</div>
----
<p for="i, . in ['a', 'b', 'c']">{i}: {.}</p>
----
<h1>{{header}}</h1>
{{#bug}}
{{/bug}}

{{#items}}
  {{#first}}
    <li><strong>{{name}}</strong></li>
  {{/first}}
  {{#link}}
    <li><a href="{{url}}">{{name}}</a></li>
  {{/link}}
{{/items}}

{{#empty}}
  <p>The list is empty.</p>
{{/empty}}

{
    header = {"hello world"}; 
    items = {[{name:"blah"}, {url: "foo", name: "foo"}]}; 
}

<h1>{header}</h1>
<li for="items">
    <do elide>
        <a href="{.url}">{.name}</a>
        <else>
        <strong>{.name}</strong>
    </do>
</li>
----
{
    t = {[
       ['a', 'b', 'c'],
       {name:"hello", key: "ok"}
    ]}
}
<p for="t">
  <b class="{.class _}" for="t_tmpl.forloop(.)">
      {.counter}/{.counter0}/{.key}/{.value}/{.first}/{.last}
  </b>
</p>
----
<p for="t_tmpl.forloop(1..10)">
  {.current}
</p>
total: {.sum}

{
  data = {[
      {'cars': 2, 'tvs': 1, 'kids': 0},
      {'cars': 0, 'tvs': 0, 'kids': 0},
      {'cars': 1, 'tvs': 2, 'kids': 0},
      {'cars': 3, 'tvs': 3, 'kids': 0},
      {'cars': 2, 'tvs': 2, 'kids': 2},
      {'cars': 2, 'tvs': 3, 'kids': 0},
      {'cars': 2, 'tvs': 2, 'kids': 1},
  ]}
}

<table>
<tr for="t_tmpl.forloop(data, {preclass:'pre', postclass:'post'})">
  <do if=".pre">
      <th></th>
      <th>Cars</th>
      <th>TVs</th>
      <th>Kids</th>
  <else>
      <td if=".post">
          Total:
          <else>
          {.counter}
      </td>
      <td>{.current.cars}</td>
      <td>{.current.tvs}</td>
      <td>{.current.kids}</td>
  </do>
</tr>
----
<p for if use="wtf" def set param>hello!{.}</p>
'''


TESTS = map(str.strip, TESTS.split('----'))
del TESTS[:-3]  # just do last 3



if __name__ == '__main__':
    import sys
    def read(f): 
        with open(f) as fh:
            return fh.read()
    if sys.argv[1:]:
        TESTS = map(read, sys.argv[1:])
    for ix, test in enumerate(TESTS):
        print '---- %d: input ----' % (ix+1)
        print test
        print '---- %d: output ----' % (ix+1)
        py = compile(test, '<test:%d>' % (ix+1))
        print py
        print '---- %d: result ----' % (ix+1)
        d = {}
        try:
            exec py in d, d
            print d['html'](a='a')
        except Exception, e:
            import traceback
            traceback.print_exc()
        
        